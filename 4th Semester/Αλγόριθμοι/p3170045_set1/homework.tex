\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[greek, english]{babel}
\usepackage[fleqn]{amsmath}
\usepackage{IEEEtrantools}
\usepackage{enumerate}
\usepackage[shortlabels]{enumitem}
\usepackage{moreenum}
\usepackage{alphabeta}
\usepackage{libertine}
\usepackage{amsfonts}
\usepackage{fixltx2e}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{float}
\usepackage[dvipsnames]{xcolor}


\title{Εργασια 1}
\date{2020-05-20}
\author{Φίλιππος Δουραχαλής}

\newcommand\dlhinf{\stackrel{\frac{\infty}{\infty}}{=}}

\begin{document}
    \begin{center}
        \textcolor{RoyalBlue}{\section*{1η Σειρά Ασκήσεων}}
    \end{center}
    \begin{flushleft}
        \textbf{Ονοματεπώνυμο: Φίλιππος Δουραχαλής}\\
        \textbf{A.M: 3170045}\\[10pt]

        \textcolor{Turquoise}{\textbf{Άσκηση 1.1}}

    \end{flushleft}
    \begin{enumerate}[label=(\greek*)]
        \item  $f(n) = n^{1/2}$\: και \:$g(n) = n^{3/4}$

        \begin{IEEEeqnarray*}{rCl}
            \lim_{n\to\infty} \frac{f(n)}{g(n)} &=&
            \lim_{n\to\infty} \bigg(\frac{n^{1/2}}{n^{3/4}}\bigg) =
            \lim_{n\to\infty} \big(n^{1/2 - 3/4}\big) \\[5pt]
            &=&\lim_{n\to\infty} n^{-1/4} =
            \lim_{n\to\infty} \bigg(\frac{1}{n^{1/4}}\bigg) \\[5pt]
            &=& 0
        \end{IEEEeqnarray*}

        άρα προκύπτει ότι
        \begin{align*}
            f(n) = O(g(n)) \text{ και } f(n) \neq \Theta(g(n))\\[10pt]
        \end{align*}
        
        \item $f(n) = 100n+ \log n$\: και \:$g(n) = n+ (\log n)^2$

        \begin{IEEEeqnarray*}{rCl}
            \lim_{n\to\infty} \frac{f(n)}{g(n)} &=&
            \lim_{n\to\infty} \Big(\frac{100n+ \log n}{n+ (\log n)^2}\Big) \dlhinf
            \lim_{n\to\infty} \Big(\frac{100 + 1/n}{1 + 2\log n/n}\Big) \\[5pt]
            &=&\lim_{n\to\infty} \Big(\frac{100n + 1}{n +2\log n}\Big) \dlhinf{}
            \lim_{n\to\infty} \Big(\frac{100}{1 + 2/n}\Big) \\[5pt] 
            &=& \lim_{n\to\infty} \Big(\frac{100n}{n + 2}\Big)
            \dlhinf{}\lim_{n\to\infty} \Big(\frac{100}{1}\Big) \\[5pt]
            &=& 100
        \end{IEEEeqnarray*}
        \\[10pt]
        Επομένως $f(n) = \Theta(g(n))$
        \\[45pt]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
        \item $f(n) = n2^n$\: και \:$g(n) = 3^n$
        
        \item 
        
        \begin{IEEEeqnarray*}{rCl}
            \lim_{n\to\infty} \frac{g(n)}{f(n)} &=& \lim_{n\to\infty} \bigg(\frac{3^n}{n2^n}\bigg) 
            = \lim_{n\to\infty} \bigg(\frac{3^n/2^n}{n}\bigg)\\[7pt]
            &=& \lim_{n\to\infty} \bigg(\frac{(3/2)^n}{n}\bigg)
            \dlhinf{} \lim_{n\to\infty} \bigg(\frac{log (\frac{3}{2})(3/2)^n}{1}\bigg)\\[7pt]
            &=& \lim_{n\to\infty} log \Big(\frac{3}{2}\Big)\Big(\frac{3}{2}\Big)^{\displaystyle n}
            = \log\Big(\frac{3}{2}\Big)*\lim_{n\to\infty} \Big(\frac{3}{2}\Big)^{\displaystyle n}\\[7pt]
            &=& \log \Big(\frac{3}{2}\Big) * \infty = \infty
        \end{IEEEeqnarray*}
        \\[5pt]
        Επομένως $f(n) = O(g(n)) \text{ και ακόμα } f(n) \neq Θ(g(n))$
        \\[5pt]
        \item $f(n) = \sum_{k = 1}^{n} \binom{n}{k}$ και $g(n) = 2^n$\\[5pt]
        Από Διωνυμικό Θεώρημα:
        \begin{IEEEeqnarray*}{rCl}
            \sum_{k = 0}^{n} \binom{n}{k} α^k β^{n-k} = (α + β)^n\\
        \end{IEEEeqnarray*}
        άρα
        \begin{IEEEeqnarray*}{rCl}
            \sum_{k = 0}^{n} \binom{n}{k} 1^k 1^{n-k} = 2^n
        \end{IEEEeqnarray*}
        και επιπλέον το $\sum_{k = 1}^{n} \binom{n}{k} 1^k 1^{n-k} = 2^n - 1$ αφού παραλείπεται ο όρος $\binom{n}{0} = 1$\\[5pt]
        Έτσι έχουμε:
        \begin{IEEEeqnarray*}{rCl}
            \lim_{n\to\infty} \frac{2^n - 1}{2^n} &=& \lim_{n\to\infty} \Big(\frac{2^n}{2^n} - \frac{1}{2^n}\Big)\\[7pt]
            &=& \lim_{n\to\infty} \frac{2^n}{2^n} - \lim_{n\to\infty} \frac{1}{2^n}\\[7pt]
            &=& 1 - 0\\
            &=& 1
        \end{IEEEeqnarray*}
        \\[5pt]
        Επομένως $f(n) = \Theta(g(n))$
        \\[5pt]
        \item $f(n) = n!$ και $g(n) = 2^n$\\[5pt]
        Έστω $2^n < n!$\\
        
        Για $n = 4$ η ανισότητα ισχύει, αφού $16 = 2^4  < 4! = 24$\\
        Έστω ότι ισχύει και για $n = r$, με $n > 4$\\

        Δείχνουμε ότι η ανίσωση ισχύει και για $ n = r+1$, δηλαδή\\
        \begin{IEEEeqnarray*}{rCl}
            (r+1)! &=& (r+1)*r!\\
            &>& (r+1)2^r\\
            &>& 2*2^r\\
            &=& 2^{r+1}
        \end{IEEEeqnarray*}
        Άρα $n! > 2^n$ και επομένως
        \begin{IEEEeqnarray*}{rCl}
            n! \geq c2^n\\
            \frac{n!}{2^n} \geq c
        \end{IEEEeqnarray*}
        Για c=1, \[\frac{n!}{2^n} \geq 1 \quad\text{, ισχύει } \forall n \geq 4\]
        Άρα $n! = Ω(2^n)$

        \item $f(n) = n!$ και $g(n) = n^n$\\[5pt]
        
        \begin{IEEEeqnarray*}{rCl}
            n! = n*(n-1)*...*2*1 < n*n*...*n*n = n^n, \quad \forall n \geq 1
        \end{IEEEeqnarray*}

        Άρα $n! = O(n^n)$
        \\[10pt]
    \end{enumerate}
    \begin{flushleft}
    
        \textcolor{Turquoise}{\textbf{Άσκηση 1.2}}
    
    \end{flushleft}
    \begin{enumerate}
        \item Άθροισμα k-υποσυνόλου\\[15pt]
        \underline{Περιγραφή αλγορίθμου:}

            Ο αριθμός όλων των πιθανών k-υποσυνόλων είναι:
             \[\binom{n}{k} = \frac{n!}{k!(n-k)!}\]
            Ο εξαντλητικός αλγόριθμος μπορέι να υπολογίζει αναδρομικά όλα τα διαφορετικά k-υποσύνολα
            και για κάθε ένα απο αυτά να εξετάζει αν το άθροισμα των στοιχείων τους ισούται με Μ.

            Συγκεκριμένα, έστω $S = \{s_1, s_2,..., s_n\}$. Αν το A μπορεί να σχηματιστεί επιλέγοντας k
            στοιχεία του S, τότε μπορούμε επίσης να σχηματίσουμε τουλάχιστον ένα από τα ποσά 
            $M-s_n, M-s_{n-1},..., M-s_1$ με το πολύ k-1 αντικείμενα. 
            
            Ορίζουμε ως C(M, k) την αναδρομική εξίσωση που 
            επιστρέφει 1 αν υπάρχει υποσύνολο του S με k στοιχεία και άθροισμα Μ και 0 διαφορετικά.

            Για την C ισχύει ότι:
            \[C(M,k) = max\{C(M-s_i, \: k-1)\}\quad \text{, για } i=0, 1,...,n\], δηλαδή βρίσκουμε όλα τα υποσύνολα k-1 στοιχείων και άθροισμα $M-s_i$ 

            Για $k=0, V>0$, \[C(V,0) = 0\], εφόσον το V είναι θετικό, δεν μπορεί να σχηματιστεί με 0 στοιχεία

            Για $V<0$, \[C(V,k) = 0\], καθώς ένα υποσύνολο θετικών ακεραίων δεν μπορεί να έχει αρνητικό άθροισμα

            Για $k=0, V=0$, \[C(0,0) = 1\], αφού κάθε μηδενικό άθροισμα μπορεί να σχηματιστεί επιλέγοντας 0 στοιχεία
            
            Με βάση τα ανωτέρω η αναδρομική εξίσωση θα είναι:
            \[ C(v, i) =\begin{cases} 
                1 & v = i =0 \\
                0 & v>0,\:i=0 \quad\\
                max\{C(v-s_i, \: i-1)\} &i=1,...,k\\
                max\{C(v, \: i-1)\} &s_i>v
                    \end{cases}
            \]

        \item Άθροισμα υποσυνόλου  
        
        \underline{Περιγραφή αλγορίθμου:}

            Αντίστοιχα με το προηγούμενο ερώτημα, θέλουμε να βρούμε αν υπάρχει υποσύνολο i
            στοιχείων με άθροισμα Μ, για οποιοδήποτε $i = 0,1,...,n$

            Για κάθε στοιχείο έχουμε την επιλογή να το προσθέσουμε στο υποσύνολο ή να το αφήσουμε εκτός 
            και να εξετάσουμε τα υπόλοιπα στοιχεία. Έτσι θα καλύψουμε όλους τους δυνατούς συνδυασμούς των n στοιχείων, 
            που είναι $2^n$. 

            Ορίζω την C(M,i) έτσι ώστε να επιστρέφει 1 αν μπορούμε να βρούμε υποσύνολο i στοιχείων με άθροισμα Μ και 0 διαφορετικά.

            Με βάση την παραπάνω λογική θα είναι \[C(M,n) = C(M, n-1) \lor C(M-s_n, n-1)\]
            
            και γενικά \[ C(v, i) =\begin{cases} 
                1 & v =0 \\
                0 & v>0,\:i=0 \quad\text{ ή }\quad V< 0\\
                C(v-s_i, \: i-1) \lor C(v, i-1) &i=1,...,k\\
                C(v, \: i-1) &s_i > v
                    \end{cases}
            \]

        \underline{Πολυπλοκότητα αλγορίθμου}
        
        Γνωρίζουμε πως ο αναδρομικός αλγόριθμος βρίσκει όλα τα πιθανά υποσύνολα του S, υποθέτωντας σε κάθε 
        βήμα πως το στοιχείο i βρίσκεται ή όχι σε κάθε ένα από αυτά τα υποσύνολα. Εφόσον χρειάζεται να ελέγξει 
        Στη χειρότερη περίπτωση λοιπόν θα χρειαστεί να ελέγξει $2^n$ υποσύνολα και άρα η πολυπλοκότητα
        του αλγορίθμου θα είναι $Ο(2^n)$
    \end{enumerate}

    \begin{flushleft}
        \textcolor{Turquoise}{\textbf{Άσκηση 1.3}}

    \end{flushleft}
    Οι αναδρομικές εξισώσεις του χρόνου εκτέλεσης για κάθε περίπτωση θα είναι οι εξής: 
    \begin{enumerate}[a.]
        \item $T(n) = 4T(n/4) +7n$
        
        Από Master Theorem:
        \begin{flalign*}
            &f(n) = 7n\\
            &a = b = 4 \text{, άρα}\\
            &n^{\log_4{4}} = n^1 = \Theta(n)
        \end{flalign*}
        \\εφόσον ισχύει ότι $7n = \Theta(n^{log_4{4}}) = \Theta(n)$ τότε ισχύει η 2η περίπτωση του Θεωρήματος:\\
        \begin{flalign*}
            T(n) &= \Theta(n^{\log_b a }\log n) = \Theta(n\log n)
        \end{flalign*}
        \item $T(n) = 4T(n/16) + n^{\frac{5}{4}}$
         
        Από Master Theorem:
        \begin{flalign*}
            &f(n) = n^{5/4}\\
            &a=4, b=16=a^2 \text{, άρα }\\
            &n^{\log_{16} 4} = n^{1/2}
        \end{flalign*}
        Άρα η $f(n) = n^{5/4} = \Omega(n^{log_{16}4 + ε}) = \Omega(n^{1/2 + ε})$ αφού $f(n) > n^{log_{16} 4}$\\

        και επιπλέον
        \begin{flalign*}
            af\Big(\frac{n}{b}\Big) &=
            4f\Big(\frac{n}{16}\Big) = 4\Big( \Big( \frac{n}{16}\Big)^{5/4}\Big) = \frac{n^{5/4}}{256}\\[5pt] 
            &\leq cf(n) \text{, με } c = \frac{1}{256}
        \end{flalign*}
        Επομένως ισχύει η 3η περίπτωση, δηλαδή $T(n) = \Theta(\sqrt[4]{n^5})$\\

        \item $T(n) = 8T(n/4) +6\sqrt n$
        
        Από Master Theorem:
        \begin{flalign*}
            &f(n) = 6\sqrt{n} = 6n^{1/2}\\
            &a=8, b=4 \text{, άρα }\\
            &n^{\log_{4} 8} = n^{3/2}
        \end{flalign*}
        Aρα η $f(n) = 6\sqrt{n} = O(n^{log_{4}8 - ε}) = O(n^{3/2 + ε})$ για $ε \simeq 0.5$ \\[3pt]
        αφού $f(n) < n^{log_{4} 8}$\\[5pt] 
        και η λύση είναι\\[3pt]
        $T(n) = \Theta(n^{log_{4}8}) = \Theta(n^{3/2}) = \Theta(n\sqrt{n})$ \\[3pt]
        βάσει της 1ης περίπτωσης του Θεωρήματος\\

        \item $T(n) = 2T(n - 2) + \Theta(1)$\\[5pt]
        Λύνουμε την εξίσωση με τη μέθοδο της αντικατάστασης:\\[5pt]
        Αρχικά παρατηρούμε πως η αναδρομική εξίσωση δημιουργεί ένα πλήρες δυαδικό δέντρο. Η αναδρομή σταματάει όταν $n - 2i = 0$,
         δηλαδή για $i = \frac{n}{2}$, που σημαίνει πως το δέντρο έχει n/2 + 1 επίπεδα. Όλοι οι κόμβοι ενός επιπέδου 
         συνεισφέρουν σταθερό κόστος Θ(1). Εφόσον υπάρχουν $2^{n/2}-1$ κόμβοι στο δέντρο, το συνολικό κόστος πρέπει να είναι 
         $(2^{n/2} - 1)Θ(1)$, άρα εικάζουμε ότι η T φράσεται άνω από την $2^n$ και άρα $T(n) = O(2^n)$\\[5pt]
        \underline{Επαγωγικη απόδειξη}\\

        Για $n = 0$ η βασική περίπτωση ισχύει.\\
        Έστω ότι $T(n) \leq c2^n -d$\\
        Δείχνουμε ότι ισχύει και για $n - 2$
        \begin{flalign*}
            T(n) &\leq 2(c2^{n-2} -d) + k\\
            &= c2^{n-1} -2d +k\\
            &\leq c2^n - 2d +k\\
            &\leq c2^n -d
        \end{flalign*}
        Άρα εφόσον $c2^n -d < c2^n$, $T(n) = O(2^n)$\\

        Από τους παραπάνω χρόνους εκτέλεσης χειρότερης περίπτωσης των αλγορίθμων, παρατηρούμε πως ο 
        d έχει τον χειρότερο.
        
        Γνωρίζουμε επίσης ότι $n^{3/2} > n^{5/4}$ και άρα αρκεί να συγκρίνουμε την
        $n^{5/4}$ με την $n\log n$ για να αποφασίσουμε ποιά είναι καλύτερη.\\
        \begin{IEEEeqnarray*}{rCl}
            \lim_{n\to\infty} \frac{n^{5/4}}{nlogn} &=& \lim_{n\to\infty} (\frac{n^1/4}{logn})\\[5pt]
            &\dlhinf{}& \lim_{n\to\infty} \frac{1}{4}(\frac{n^{-3/4}}{1/n})\\[5pt]
            &=& \lim_{n\to\infty} \frac{1}{4} n^{1/4}\\[5pt]
            &=& \infty
        \end{IEEEeqnarray*}
        Άρα το $n\log n$ αποτελεί καλύτερο άνω φράγμα, οπότε επιλέγουμε τον αλγόριθμο b για να λύσουμε το Π.
    \end{enumerate} 
    \begin{flushleft}

        \textcolor{Turquoise}{\textbf{Άσκηση 1.4}}
    
    \end{flushleft}
    Έστω ο πίνακας A με $|Α| = n$. 
    Χρησιμοποιούμε τον αλγόριθμο της MergeSort για να ταξινομήσουμε τον Α.

    Σε κάθε βήμα της αναδρομής ο πίνακας διαιρείται σε δύο υποπίνακες L και R οι οποίοι στη συνέχεια συγχωνεύονται.
    Κατά τη διαδικασία της συγχώνευσης οι L και R είναι ταξινομημένοι (αφού είτε αποτελούνται από 1 στοιχείο στη τερματική
    περίπτωση ή έχουν προκύψει από προηγούμενη συγχώνευση και άρα έχουν ταξινομηθεί ήδη). Άρα σε αυτό το επίπεδο θέλουμε 
    να μετρήσουμε πόσες αντιστροφές υπάρχουν συνολικά μεταξύ των πινάκων και να επιστρέψουμε το πλήθος τους

    Στο στάδιο της συγχώνευσης συγκρίνουμε διαδοχικά τα $mid-l+1$ στοιχεία του L με τα $r-mid$ στοιχεία του R για να καθορίσουμε ποιό είναι μικρότερο. 
    Σε αυτό το βήμα είναι εύκολο να βρούμε πόσες αντιστροφές υπάρχουν στους δύο αυτούς πίνακες, αφού όταν βρούμε ένα στοιχείο i του L
    που είναι μεγαλύτερο από κάποιο στοιχείο j του R, το ίδιο θα ισχύει για τα $i, i+1,..., mid$ στοιχεία του L (λόγω ταξινόμησης).

    Επομένως είμαστε σίγουροι πως σε αυτό το επιπέδο υπάρχουν τόσες αντιστροφές όσες και τα $mid-l+1-i$ στοιχεία του L που απομένουν.

    Άρα αρκεί να τροποποιήσουμε την MergeSort ώστε να κρατάει το πλήθος αυτό μέχρι όλα τα στοιχεία να είναι στις σωστές τους θέσεις
    και αρα να έχουν μετρηθεί όλες οι αντιστροφές στοιχείων των συστοιχειών L και R σε κάθε αναδρομικό βήμα ως εξής:
    
    (Σημείωση: Ως βάση χρησιμοποιείται ο αλγόριθμος του βιβλίου "Εισαγωγή στους Αλγορίθμους)

    \begin{algorithm}[H]
        \caption{Άσκηση 1.4}
        \begin{algorithmic}[1]
            \Procedure{sort}{A, left, right}
            \State inv = 0
            \If{$left < right$} \State $q = (right - left)/2$
            \State inv = inv +  SORT$(A,left ,q)$
            \State inv = inv +  SORT$(A,q+1, right)$
            \State inv = inv +  MERGE$(A, left, q, right)$
            \EndIf
            \Return inv
            \EndProcedure
            \vspace{5mm}
            \Procedure{merge}{A, l, mid, r}
            \State inv = 0
            \State lengthL =$ mid-l+1$
            \State lengthR = $r-mid$
            \State L[1...lengthL + 1]
            \State R[1...lengthR + 1]
            \For{$ i = 1 \textbf{ to } lengthL$}
                \State L$[i] = $A$[left + i -1]$
            \EndFor
            \For{$ j = 1 \textbf{ to } lengthR$}
                \State R$[j] = $A$[mid + j]$
            \EndFor
            \State L[lengthL + 1] = $\infty$ \Comment{Φρουρος τελους συστοιχίας L}
            \State R[lengthR + 1] = $\infty$ \Comment{Φρουρος τελους συστοιχίας R}
            \State $i = 1$
            \State $j = 1$
            \For{$ k = left \textbf{ to } right$} 
                \If{L$[i] \leq $R$[j]$} \State A$[k] = $L$[i]$ \State $i = i + 1$
                \Else   
                        \State $\triangleright$\text{Κάθε στοιχείο του L μετά το i θα είναι επίσης μεγαλύτερο του R[j]} 
                        \State A$[k] = $R$[j]$ \State $j = j + 1$ 
                        \State inv = inv + lengthL - $i$
                \EndIf
            \EndFor
            \Return inv
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}
    \begin{flushleft}
        \textbf{\underline{Πολυπλοκότητα Αλγορίθμου}} 
    \end{flushleft}

    Ο αλγόριθμος παρουσιάζει ίδια πολυπλοκότητα με τον αλγόριθμο της MergeSort, δηλαδή\\
    $T(n) = 2T(n/2) + cn$\\
    Χρησιμοποιώντας το Θεώρημα Κυρίαρχου Όρου παίρνουμε:
    \begin{flalign*}
        &f(n) = cn\\
        &a=2, b=2 \text{, άρα }\\
        &n^{\log_2 2} = n
    \end{flalign*}
    Αφού $f(n) = \Theta(n)$, ισχύει ότι $T(n) = \Theta(nlogn)$
    \vspace{5mm}
    \begin{flushleft}

        \textcolor{Turquoise}{\textbf{Άσκηση 1.6}}
    
    \end{flushleft}

    Έστω σύνολο  $W = {w_1, w_2, ..., w_n}$ που περιέχει τα βάρη κάθε αντικειμένου $w_i$ για i = 1, ..., n
    και $C\in\mathbb{N}$ η χωρητικότητα μίας κούτας.

    Έστω ακόμη το σύνολο $A \subseteq N$ που περιέχει τα αντικείμενα μιας βέλτιστης λύσης.

    Το πρόβλημα μπορεί να λυθεί αντίστοιχα με το διακριτό πρόβλημα του σακιδίου, με την διαφορά 
    ότι μας αρκεί ο αλγόριθμος να επιστρέφει true αν βρεί κάποιο υποσύνολο με άθροισμα στοιχείων C.

    Δεδομένου ότι το Α αποτελεί βέλτιστη λύση, αφαιρώντας το στοιχείο $w_n$ από το W, η λύση του 
    προβλήματος για $W-{w_n}$ είναι το σύνολο Α\textbackslash${w_n}$ που είναι επίσης βέλτιστο.
    Άρα αρκεί να πάρουμε περιπτώσεις, αναλόγως αν η λύση (το Α) περιέχει το $w_n$ ή όχι
        
    Αν συμβολίσουμε f(n, C) τη λύση που επιστρέφει ο αλγόριθμος για είσοδο το σύνολο W με $|W|=n$ και τη χωρητικότητα C,
    παίρνουμε τις περιπτώσεις για το f όπως περιγράφηκαν πιο πάνω:
    \begin{enumerate}
        \item $f(n-1, C)$ υποθέτωντας ότι η λύση δεν περιέχει το n και
        \item $f(n-1, C-w_n)$ αν η λύση το περιέχει
    \end{enumerate} 

    Η f(i, y) θα πρέπει να γίνεται 1 αν υπάρχει υποσύνολο i στοιχείων με άθροισμα y και 0 αν δεν υπάρχει. 
    Το υποσύνολο αυτό μπορεί να έχει ή όχι το αντικείνο n και άρα:
    \[f(n,C) = f(n-1, C) \lor f(n-1, C - w_n)\]

    \begin{flushleft} \underline{\textbf{a) Αναδρομική εξίσωση}} \end{flushleft}  

    Ορίζουμε την f ως εξής:
    \[ f(i, y) =\begin{cases} 
                1 & y = 0 \\
                0 & i = 0 \text{ και } y \neq 0 \\
                f(i-1, y) \lor f(i-1, y - w_i) & i>1\\
                f(i-1, y) & w_i > y 
                \end{cases}
    \]
    \vspace{5mm}

    Με αυτόν τον τρόπο κατασκευάζουμε αναδρομικά τη λύση της f, σταματώντας όταν το βάρος y=0, δηλαδή όταν έχουμε προσθέσει στην λύση μας k αντικείμενα του W με άθροισμα y ή όταν δεν έχουμε 
    άλλα αντικείμενα να προσθέσουμε στη λύση.

    Εφόσον έχουμε την αναδρομική λύση εκθετικού χρόνου, μπορούμε να κατασκευάσουμε έναν επαναληπτικό αλγόριθμο ως εξής:
    \begin{algorithm}[H]
        \caption{Άσκηση 1.6}
        \begin{algorithmic}[1]
            \For{$ i=1 \textbf{ to } n$} \State $f(i, 0) \gets true$ 
            \EndFor
            \For{$ i=1 \textbf{ to } C$} \State $f(1, i) \gets w_i == i$
            \EndFor
            \For{$ i=2 \textbf{ to } n$} 
                \For{$ y=1 \textbf{ to } C$}
                \If {$w_i > y$}
                    \State $f(i,y) \gets f(i-1, y)$
                \Else
                    \State $f(i,y) \gets f(i-1, y) \lor f(i-1, y-w_i) $
                \EndIf
                \EndFor
            \EndFor
            \Return $f(n,C)$
        \end{algorithmic}
    \end{algorithm}

    Το τελευταίο κελί του πίνακα f που δημιουργείται αναπαριστά ολόκληρο το προβλημα. Αν είναι true, σημαίνει πως τουλάχιστον ένα απο τα 2 υποπροβλήματα και κατά συνέπεια
    το αρχικό πρόβλημα έχει βέλτιστη λύση
    \begin{flushleft}\underline{\textbf{b) Πολυπλοκότητα Αλγορίθμου}}\end{flushleft}
    \vspace{5mm}

    Στις γραμμές 1-4 αρχικοποιείται ένας πίνακας μεγέθους n x (C+1). Η πρώτη στήλη του πίνακα (για C = 0) περιέχει true
    αφού σε αυτή τη περίπτωση αρκεί να μην επιλέξουμε κανένα στοιχείο. Η πρώτη γραμμή του πίνακα γίνεται false, με εξαίρεση το κελί όπου το βάρος του
    πρώτου στοιχείου του W ισούται με το y, καθώς τότε αυτό ανήκει στη λύση του υποπροβλήματος $(1, w_1)$ και άρα είναι true.
    Στις γραμμές 5-10 υπολογίζουμε τις υπόλοιπες τιμές της f βάσει των περιπτώσεων που αναφέρονται παραπάνω.

    Τα δύο πρώτα for τρέχουν n και C φορές, σε χρόνο Ο(n) και O(C) αντίστοιχα, ενώ οι πράξεις μέσα σε κάθε επανάληψη
    εκτελούνται σε σταθερό χρόνο Ο(1).  Το for της γραμμής 8 εκτελείται C φορές για κάθε στοιχείο του συνόλου W
    δηλαδή συνολικά (n-1)*C φορές (έχουμε ήδη υπολογίσει τις τιμές του πρώτου στοιχείου του πίνακα W), 
    ενώ οι πράξεις μέσα του εκτελούνται επίσης σε σταθερό χρόνο.

    Άρα συνολικά ο χρόνος εκτέλεσης του αλγορίθμου είναι \[n*O(1) + C*O(1) + (n-1)*C*O(1) = O(nC) \] 

    Σχετικά με την πολυπλοκότητα χώρου, κατα την εκτέλεση του αλγορίθμου δημιουργείται μόνο ο πίνακας f 
    ο οποίος αποτελείται απο (n * (C+1)) κελιά και άρα απαιτεί χώρο O(n*(C+1)) = O(n*C)

\end{document}